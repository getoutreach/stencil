// Copyright 2022 Outreach Corporation. All Rights Reserved.

// Description: See package description

// Package codegen has code generators for Go projects
//
// This is intended for use with stencil but can also be used
// outside of it.
//
// Using configuration.ServiceManifest, a list of template repositories
// is created and cloned into a layered filesystem with the sub-dependencies
// of the root dependency (the module) being used first, and so on. This layered
// fs is then walked to find all files with a `.tpl` extension. These are rendred
// and turned into functions.RenderedTemplate objects, and then written to disk
// based on the template's function calls.
//
// This is the core of stencil
package codegen

import (
	"context"
	"os"
	"os/exec"
	"path/filepath"

	"github.com/getoutreach/stencil/internal/functions"
	"github.com/getoutreach/stencil/internal/modules"
	"github.com/getoutreach/stencil/pkg/configuration"
	"github.com/getoutreach/stencil/pkg/extensions"
	"github.com/getoutreach/stencil/pkg/stencil"
	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	"gopkg.in/yaml.v3"
)

// Builder is the heart of stencil, running it is akin to running
// stencil. Builder handles fetching stencil dependencies and running
// the actual templating engine and writing the results to disk. Also
// handled is the extension framework
type Builder struct {
	// dir is the path to write templates to
	dir string

	// manifest is the service manifest that is being used
	// for this template render
	manifest *configuration.ServiceManifest

	// extensions is the extensions host that handles all extensions
	// exposed to templates for this builder
	extensions *extensions.Host

	// log is the logger used for logging output
	log logrus.FieldLogger

	// modules is a list of all modules that this builder is utilizing
	modules []*modules.Module
}

// NewBuilder returns a new builder
func NewBuilder(dir string, log logrus.FieldLogger, s *configuration.ServiceManifest) *Builder {
	_, err := stencil.LoadLockfile("")
	if !errors.Is(err, os.ErrNotExist) {
		log.WithError(err).Warn("failed to load lockfile")
	}

	return &Builder{
		dir:        dir,
		manifest:   s,
		extensions: extensions.NewHost(),
		log:        log,
	}
}

// Run fetches dependencies of the root modules and builds the layered filesystem,
// after that GenerateFiles is called to actually walk the filesystem and render
// the templates. This step also does minimal post-processing of the dependencies
// manifests
func (b *Builder) Run(ctx context.Context) ([]string, error) {
	var err error
	b.modules, err = modules.GetModulesForService(ctx, b.manifest)
	if err != nil {
		return nil, errors.Wrap(err, "failed to process modules list")
	}

	warnings, err := b.GenerateFiles(ctx)
	if err != nil {
		return nil, err
	}

	return warnings, b.runPostRunCommands(ctx)
}

// runPostRunCommands runs the postRunCommands set by
// dependencies
func (b *Builder) runPostRunCommands(ctx context.Context) error {
	b.log.Info("Running post run commands")
	for _, m := range b.modules {
		mf, err := m.Manifest(ctx)
		if err != nil {
			return err
		}

		for _, cmdStr := range mf.PostRunCommand {
			b.log.Infof("- %s", cmdStr.Name)

			//nolint:gosec // Why: That's the literal design.
			cmd := exec.CommandContext(ctx, "/usr/bin/env", "bash", "-c", cmdStr.Command)
			cmd.Stdin = os.Stdin
			cmd.Stderr = os.Stderr
			cmd.Stdout = os.Stdout
			if err := cmd.Run(); err != nil {
				return errors.Wrapf(err, "failed to run post run command for module %q", m.Name)
			}
		}
	}

	return nil
}

// GenerateFiles walks the vfs generated by Run() and renders the templates
func (b *Builder) GenerateFiles(ctx context.Context) ([]string, error) {
	st := functions.NewStencil(b.manifest, b.modules)

	b.log.Info("Rendering templates")
	tpls, err := st.Render(ctx)
	if err != nil {
		return nil, err
	}
	return nil, b.writeFiles(st, tpls)
}

func (b *Builder) writeFile(f *functions.File) error {
	action := "Created"
	if f.Deleted {
		action = "Deleted"
		os.Remove(f.Name())
	} else if f.Skipped {
		action = "Skipped"
	} else if _, err := os.Stat(f.Name()); err == nil {
		action = "Updated"
	}

	// TODO(jaredallard): Better way to do this...
	if action == "Created" || action == "Updated" {
		if err := os.MkdirAll(filepath.Dir(f.Name()), 0o755); err != nil {
			return errors.Wrapf(err, "failed to ensure directory for %q existed", f.Name())
		}

		if err := os.WriteFile(f.Name(), f.Bytes(), f.Mode()); err != nil {
			return errors.Wrapf(err, "failed to create %q", f.Name())
		}
	}

	b.log.Infof("  -> %s %s", action, f.Name())
	return nil
}

// writeFiles writes the files to disk
func (b *Builder) writeFiles(st *functions.Stencil, tpls []*functions.Template) error {
	b.log.Infof("Writing template(s) to disk")
	for _, tpl := range tpls {
		b.log.Debugf(" -> %s (%s)", tpl.Module.Name, tpl.Path)
		for _, f := range tpl.Files {
			if err := b.writeFile(f); err != nil {
				return err
			}
		}
	}

	l := st.GenerateLockfile(tpls)
	f, err := os.Create(stencil.LockfileName)
	if err != nil {
		return errors.Wrap(err, "failed to create lockfile")
	}
	defer f.Close()

	return errors.Wrap(yaml.NewEncoder(f).Encode(l),
		"failed to encode lockfile into yaml")
}
