// Copyright 2022 Outreach Corporation. All Rights Reserved.

// Description: This file implements the stenciltest framework
// for testing templates generated by stencil.

// Package stenciltest contains code for testing templates
package stenciltest

import (
	"context"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"

	"github.com/bradleyjkemp/cupaloy"
	"github.com/getoutreach/stencil/internal/codegen"
	"github.com/getoutreach/stencil/internal/modules"
	"github.com/getoutreach/stencil/internal/modules/modulestest"
	"github.com/getoutreach/stencil/pkg/configuration"
	"github.com/sirupsen/logrus"
	"gopkg.in/yaml.v3"
)

// Template is a template that is being tested by the stenciltest framework.
type Template struct {
	// path is the path to the template.
	path string

	// aditionalTemplates is a list of additional templates to add to the renderer,
	// but not to snapshot.
	additionalTemplates []string

	// m is the template repository manifest for this test
	m *configuration.TemplateRepositoryManifest

	// t is a testing object.
	t *testing.T

	// args are the arguments to the template.
	args map[string]interface{}
}

// New creates a new test for a given template.
func New(t *testing.T, templatePath string, additionalTemplates ...string) *Template {
	// GOMOD: <module path>/go.mod
	b, err := exec.Command("go", "env", "GOMOD").Output()
	if err != nil {
		t.Errorf("failed to determine path to manifest: %v", err)
	}
	basepath := strings.TrimSuffix(strings.TrimSpace(string(b)), "/go.mod")

	b, err = os.ReadFile(filepath.Join(basepath, "manifest.yaml"))
	if err != nil {
		t.Error(err)
	}

	var m configuration.TemplateRepositoryManifest
	if err := yaml.Unmarshal(b, &m); err != nil {
		t.Error(err)
	}

	return &Template{
		t:                   t,
		m:                   &m,
		path:                templatePath,
		additionalTemplates: additionalTemplates,
	}
}

// Args sets the arguments to the template.
func (t *Template) Args(args map[string]interface{}) *Template {
	t.args = args
	return t
}

// Run runs the test.
func (t *Template) Run(save bool) {
	t.t.Run(t.path, func(got *testing.T) {
		m, err := modulestest.NewModuleFromTemplates(t.m.Arguments, append([]string{t.path}, t.additionalTemplates...)...)
		if err != nil {
			got.Errorf("failed to create module from template %q", t.path)
		}

		mf := &configuration.ServiceManifest{Name: "testing", Arguments: t.args,
			Modules: []*configuration.TemplateRepository{{Name: m.Name}}}
		st := codegen.NewStencil(mf, []*modules.Module{m})

		tpls, err := st.Render(context.Background(), logrus.New())
		if err != nil {
			got.Errorf("failed to render: %v", err)
		}

		for _, tpl := range tpls {
			// skip templates that aren't the one we are testing
			if tpl.Path != t.path {
				continue
			}

			for _, f := range tpl.Files {
				success := got.Run(f.Name(), func(got *testing.T) {
					snapshot := cupaloy.New(cupaloy.ShouldUpdate(func() bool { return save }), cupaloy.CreateNewAutomatically(true))
					snapshot.SnapshotT(got, f)
				})
				if !success {
					got.Errorf("Generated file %q did not match snapshot", f.Name())
				}
			}

			// only ever process one template
			break
		}
	})
}

