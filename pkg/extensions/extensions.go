// Copyright 2022 Outreach Corporation. All Rights Reserved.

// Description: See package description.

// Package extensions consumes extensions in stencil
package extensions

import (
	"context"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/blang/semver/v4"
	"github.com/getoutreach/gobox/pkg/cfg"
	"github.com/getoutreach/gobox/pkg/cli/github"
	"github.com/getoutreach/gobox/pkg/cli/updater/archive"
	"github.com/getoutreach/gobox/pkg/cli/updater/release"
	"github.com/getoutreach/gobox/pkg/cli/updater/resolver"
	"github.com/getoutreach/stencil/pkg/extensions/apiv1"
	"github.com/hashicorp/go-multierror"
	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	giturls "github.com/whilp/git-urls"
)

// generatedTemplateFunc is the underlying type of a function
// generated by createFunctionFromTemplateFunction that's used
// to wrap the go plugin call to invoke said function
type generatedTemplateFunc func(...interface{}) (interface{}, error)

// Host implements an extension host that handles
// registering extensions and executing them.
type Host struct {
	log        logrus.FieldLogger
	extensions map[string]extension
}

// extension is an extension stored on an extension host
type extension struct {
	impl   apiv1.Implementation
	closer func() error
}

// NewHost creates a new extension host
func NewHost(log logrus.FieldLogger) *Host {
	return &Host{
		log:        log,
		extensions: make(map[string]extension),
	}
}

// createFunctionFromTemplateFunction takes a given
// TemplateFunction and turns it into a callable function
func (h *Host) createFunctionFromTemplateFunction(extName string, ext apiv1.Implementation,
	fn *apiv1.TemplateFunction) generatedTemplateFunc {
	extPath := extName + "." + fn.Name

	return func(args ...interface{}) (interface{}, error) {
		if len(args) > fn.NumberOfArguments {
			return nil, fmt.Errorf("too many arguments, expected %d, got %d", fn.NumberOfArguments, len(args))
		}

		resp, err := ext.ExecuteTemplateFunction(&apiv1.TemplateFunctionExec{
			Name:      fn.Name,
			Arguments: args,
		})
		if err != nil {
			// return an error if the extension returns an error
			return nil, errors.Wrapf(err, "failed to execute template function %q", extPath)
		}

		// return the response, and a nil error
		return resp, nil
	}
}

// GetExtensionCaller returns an extension caller that's
// aware of all extension functions
func (h *Host) GetExtensionCaller(ctx context.Context) (*ExtensionCaller, error) {
	// funcMap stores the extension functions discovered
	funcMap := map[string]map[string]generatedTemplateFunc{}

	// Call all extensions to get the template functions provided
	for extName, ext := range h.extensions {
		funcs, err := ext.impl.GetTemplateFunctions()
		if err != nil {
			return nil, errors.Wrapf(err, "failed to get template functions from plugin '%s'", extName)
		}

		for _, f := range funcs {
			h.log.WithField("extension", extName).WithField("function", f.Name).Debug("Registering extension function")
			tfunc := h.createFunctionFromTemplateFunction(extName, ext.impl, f)

			if _, ok := funcMap[extName]; !ok {
				funcMap[extName] = make(map[string]generatedTemplateFunc)
			}
			funcMap[extName][f.Name] = tfunc
		}
	}

	// return the lookup function, used via Call()
	return &ExtensionCaller{funcMap}, nil
}

// TODO(jaredallard)[DTSS-1926]: Refactor a lot of this RegisterExtension code.

// RegisterExtension registers a ext from a given source
// and compiles/downloads it. A client is then created
// that is able to communicate with the ext.
func (h *Host) RegisterExtension(ctx context.Context, source, name string, version *resolver.Version) error { //nolint:funlen // Why: OK length.
	h.log.WithField("extension", name).WithField("source", source).Debug("Registered extension")

	u, err := giturls.Parse(source)
	if err != nil {
		return errors.Wrap(err, "failed to parse extension URL")
	}

	var extPath string
	if u.Scheme == "file" {
		extPath = filepath.Join(strings.TrimPrefix(source, "file://"), "bin", "plugin")
	} else {
		extPath, err = h.downloadFromRemote(ctx, name, version)
	}
	if err != nil {
		return errors.Wrap(err, "failed to setup extension")
	}

	ext, closer, err := apiv1.NewExtensionClient(ctx, extPath, h.log)
	if err != nil {
		return err
	}

	if _, err := ext.GetConfig(); err != nil {
		return errors.Wrap(err, "failed to get config from extension")
	}
	h.extensions[name] = extension{ext, closer}

	return nil
}

// RegisterInprocExtension registers an extension that is implemented within the same process
// directly with the host. Please limit the use of this API for unit testing only!
func (h *Host) RegisterInprocExtension(name string, ext apiv1.Implementation) {
	h.log.WithField("extension", name).Debug("Registered inproc extension")
	h.extensions[name] = extension{ext, func() error { return nil }}
}

// getExtensionPath returns the path to an extension binary
func (h *Host) getExtensionPath(version *resolver.Version, name string) string {
	homeDir, _ := os.UserHomeDir() //nolint:errcheck // Why: signature doesn't allow it, yet
	path := filepath.Join(homeDir, ".outreach", ".cache", "stencil", "extensions",
		name, fmt.Sprintf("@%s", version.Commit), filepath.Base(name))
	os.MkdirAll(filepath.Dir(path), 0o755) //nolint:errcheck // Why: signature doesn't allow it, yet
	return path
}

// getVersionWithCommit retrieves a new version with the commit present.
func getVersionWithCommit(ctx context.Context, token cfg.SecretData, repoURL string,
	version *resolver.Version) (*resolver.Version, error) {
	var v *resolver.Version
	var err error
	// We assume that if the tag does not comply with semver it is a channel (e.g. unstable).
	if _, err := semver.ParseTolerant(version.Tag); err != nil {
		v, err = resolver.Resolve(ctx, token, &resolver.Criteria{
			URL:     repoURL,
			Channel: version.Tag,
		})
		if err != nil {
			return nil, errors.Wrap(err, "failed to get latest version")
		}
		return v, nil

	}
	v, err = resolver.Resolve(ctx, token, &resolver.Criteria{
		URL:         repoURL,
		Constraints: []string{version.Tag},
	})
	if err != nil {
		return nil, errors.Wrap(err, "failed to get latest version")
	}
	return v, nil
}

// downloadFromRemote downloads a release from github and extracts it to disk
//
// using the example extension module: github.com/getoutreach/stencil-plugin
//
//	org: getoutreach
//	repo: stencil-plugin
//	name: github.com/getoutreach/stencil-plugin
func (h *Host) downloadFromRemote(ctx context.Context, name string,
	version *resolver.Version) (string, error) {
	token, err := github.GetToken()
	if err != nil {
		h.log.WithError(err).Warn("Failed to get github token, falling back to anonymous")
	}

	repoURL := "https://" + name

	if version.Tag == "" {
		v, err := resolver.Resolve(ctx, token, &resolver.Criteria{
			URL: repoURL,
		})
		if err != nil {
			return "", errors.Wrap(err, "failed to get latest version")
		}
		version = v
	}

	if version.Commit == "" {
		v, err := getVersionWithCommit(ctx, token, repoURL, version)
		if err != nil {
			return "", errors.Wrap(err, "retrieving commit")

		}
		version = v
	}

	// Check if the version we're pulling already exists and is executable before downloading
	// it again.
	dlPath := h.getExtensionPath(version, name)
	if info, err := os.Stat(dlPath); err == nil && info.Mode() == 0o755 {
		return dlPath, nil
	}

	h.log.WithField("version", version).WithField("repo", repoURL).Debug("Downloading native extension")
	a, archiveName, _, err := release.Fetch(ctx, token, &release.FetchOptions{
		AssetName: filepath.Base(name) + "_*_" + runtime.GOOS + "_" + runtime.GOARCH + ".tar.gz",
		RepoURL:   repoURL,
		Tag:       version.Tag,
	})
	if err != nil {
		return "", errors.Wrap(err, "failed to fetch release")
	}

	bin, _, err := archive.Extract(ctx, archiveName, a, archive.WithFilePath(filepath.Base(name)))
	if err != nil {
		return "", errors.Wrap(err, "failed to extract archive")
	}

	f, err := os.Create(dlPath)
	if err != nil {
		return "", errors.Wrap(err, "failed to create file")
	}
	defer f.Close()

	if _, err := io.Copy(f, bin); err != nil {
		return "", errors.Wrap(err, "failed to download binary")
	}
	f.Close()

	// Ensure the file is executable.
	if err := os.Chmod(dlPath, 0o755); err != nil {
		return "", errors.Wrap(err, "failed to ensure plugin is executable")
	}

	return dlPath, nil
}

// Close terminates the extension host, which in turn stops
// all current native extensions
func (h *Host) Close() error {
	var result error
	for _, ext := range h.extensions {
		if err := ext.closer(); err != nil {
			result = multierror.Append(result, err)
		}
	}
	return result
}
