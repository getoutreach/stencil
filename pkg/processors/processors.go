package processors

import (
	"errors"
	"io"
	"path/filepath"
	"reflect"
)

var (
	ErrNotProcessable = errors.New("not a processable file")
)

type Config struct {
	// FileExtensions are the file extensions this processor should handle
	FileExtensions []string

	// FileNames are specific files this processor should handle
	FileNames []string

	// IsPostCodegenProcessor denotes whether or not the given processor
	// should be ran after the codegen stage of stencil. The main difference
	// between running a processor during the codegen stage and after the
	// codegen stage are the files each touches, respectively. The codegen
	// processors will only touch non-static files generated by stencil,
	// whereas post-codegen processors will touch every file of the repository,
	// regardless of whether or not it was generated by stencil or not.
	// Template does not get passed to Process function (see Processor
	// interface) when this bool is set to true.
	IsPostCodegenProcessor bool
}

type Processor interface {
	// Register configures this processor and returns the config object for it.
	Register() *Config

	// Process process a file and returns it
	Process(*File, *File) (*File, error)
}

type File struct {
	io.Reader

	Name string
}

type Table struct {
	processors []Processor

	fileNames map[string][]Processor
	fileExts  map[string][]Processor
}

// NewFile create a new file. If r is nil, a nil file is returned
func NewFile(r io.Reader, path string) *File {
	if r == nil || (reflect.ValueOf(r).Kind() == reflect.Ptr && reflect.ValueOf(r).IsNil()) {
		return nil
	}

	return &File{r, path}
}

// New creates a new processor
func New() *Table {
	processors := []Processor{&GoMod{}, &GoBox{}}
	t := &Table{
		processors: processors,
		fileNames:  make(map[string][]Processor),
		fileExts:   make(map[string][]Processor),
	}

	for i, p := range processors {
		cfg := p.Register()

		// Register file extensions
		for _, str := range cfg.FileExtensions {
			if _, ok := t.fileExts[str]; !ok {
				t.fileExts[str] = make([]Processor, 0)
			}

			t.fileExts[str] = append(t.fileExts[str], t.processors[i])
		}

		// Register file names
		for _, str := range cfg.FileNames {
			if _, ok := t.fileNames[str]; !ok {
				t.fileNames[str] = make([]Processor, 0)
			}

			t.fileNames[str] = append(t.fileNames[str], t.processors[i])
		}
	}

	return t
}

// Process process a file
func (t *Table) Process(postCodegen bool, existing, template *File) (*File, error) {
	var ext, name string
	if postCodegen {
		ext = filepath.Ext(existing.Name)
		name = filepath.Base(existing.Name)
	} else {
		ext = filepath.Ext(template.Name)
		name = filepath.Base(template.Name)
	}

	// Note: we only support one processor at the time
	// but our datastructure leaves support for it in the future

	for _, p := range t.fileExts[ext] {
		if p.Register().IsPostCodegenProcessor == postCodegen {
			return p.Process(existing, template)
		}
	}

	for _, p := range t.fileNames[name] {
		if p.Register().IsPostCodegenProcessor == postCodegen {
			return p.Process(existing, template)
		}
	}

	return nil, ErrNotProcessable
}
