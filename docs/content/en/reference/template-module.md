---
title: Template Module
description: Modules contain a grouping of dependencies or templates for a Stencil application
date: 2022-05-02
categories: [module, template module]
keywords: [module, template module]
menu:
  docs:
    parent: "reference"
    weight: 3
toc: true
---

A template module, sometimes referred to as a "template repository" is a module consumable by a stencil application, that contains a collection of go-templates.

## General Module Requirements

A module requires a name and a description currently that are set in the `manifest.yaml` described later on in this document.

The name of a module must be equal to the import path of the module. The import path of a module follows the same rules as Golang, where as the repository URL must equal the import path. For example, if the module is located at `https://github.com/stencil/example-module`, the import path must be `github.com/stencil/example-module`.

## Structure

A module structure typically looks like so:

- `templates/` - a directory that contains all of the go-templates that this module owns
- `manifest.yaml` - a manifest describing the arguments, dependencies and other metadata for this module
- `go.mod` - a go module file used for testing the module
- `**/.snapshots` - a directory used for snapshot testing files

### `templates/`

This directory is used for storing all of the go-templates that a module owns. By default a file that doesn't have a `.tpl` extension will be ignored by stencil. When a `.tpl` file is found, this file is written to the base of the execution directory of stencil, minus the `templates` directory and `.tpl` extension.

For example, if a module had a template at `templates/helloWorld.tpl` it would by default be written to `./helloWorld`

This can be changed with the [`file.SetPath`](/stencil/functions/file.setpath) function as needed.

Templates can also call `file.Create` to create a new file within a loop. For more information see the [`file.Create` documentation](/stencil/functions/file.create)

### `manifest.yaml`

The manifest.yaml file is arguably the most important file in a stencil module. This dictates the type of module, the arguments that the module accepts, and the dependencies that the module has.

The important keys that a module has are listed below, but an exhaustive list can be found on the [pkg.go.dev](https://pkg.go.dev/github.com/getoutreach/stencil/pkg/configuration#TemplateRepositoryManifest)

- `name` - The import path of the module
- `description` - A description of the module
- `modules` - a list of modules that this module depends on
  _ `name` - import path of the module depended on
  _ `version` - optional: A version to pin this module to.
- `arguments` - a map of arguments that this module accepts. A module cannot access an argument via `stencil.Arg` without first declaring it here.
  _ `name` - the name of the argument
  _ `description` - a description of the argument
  _ `type` - the type of the argument, can be `string`, `int`, `bool`, `list`, or `map`
  _ `default` - the default value of the argument \* `required` - whether or not the argument is required

## Module Hooks

Module hooks enable other modules to write to a section of a file in your module. This can be done with the [`stencil.GetModuleHook "name"`](/stencil/functions/stencil.getmodulehook) function. This returns a `[]interface{}`, or for non-gophers a list of any type. You can process this with a `range` or in any other method you'd like to generate whatever you need for your DSL.

A module can write to a module hook with the [`stencil.AddToModuleHook "importPath" "hookName"`](/stencil/functions/stencil.addtomodulehook) function.

## Testing a Module

Testing a module can be done in a variety of different ways, but the officially supported way of testing a module is through the testing framework that's generated by the `stencil create module` command.

More documentation can be found on the documentation for that command, but in a nutshell the default and recommended testing method for modules is snapshot testing. Snapshot testing is done by rendering the files of a module to a directory, and then comparing the rendered files to the expected files overtime. This is supported by the [`stenciltest`](https://pkg.go.dev/github.com/getoutreach/stencil@v1.14.2/pkg/stenciltest) go package.

Writing a test requires a valid `go.mod` file, as the tests are written in Go and to use the `stenciltest` package. To create a test, simply create a valid go test (e.g. `main_test.go`) and write a go test using the `stenciltest` package.

A simple example for rendering the template `helloWorld.tpl` to a file called `helloWorld` would look like so:

{{< code file="helloWorld.tpl" >}}
hello, world!
{{< /code >}}

{{< code file="main_test.go" >}}
package main

import (
"testing"

    "github.com/getoutreach/stencil/pkg/stenciltest"

)

func TestGoMod(t \*testing.T) {
// Create a renderer with the specified file being the file to test.
//
// More files may be provided if they are depended as variadic arguments
// but their output will not be saved.
st := stenciltest.New(t, "go.mod.tpl")

    // Define the arguments to pass to stencil
    st.Args(map[string]interface{}{"org": "getoutreach"})

    // Run the test, persisting the snapshot to disk if it changed.
    // Default is set to false.
    st.Run(false)

}

{{< /code >}}

You can run all tests by running `go test ./...` in the root of the repository:

```bash
$ go test ./...
...
ok      testing.com/templates  2.861s
```

### Testing a Module used in a Stencil Application

A `service.yaml` supports a `replacements` key that can be used to replace the source of a module with a different module. This is useful for testing a module that is used in a stencil application.

For example, if an application uses the `github.com/stencil/example-module` module and you want to develop on the `example-module`, a key in `replacements` can be added to point it to a different source URL or file path.

```yaml
replacements:
	# Replace it with a file path
	github.com/stencil/example-module: ../example-module

	# Replace it with a different URL
	github.com/stencil/example-module: github.com/myname/example-module
```

If you want to lock the dependency to a specific version currently replacements don't support setting the version, but instead you'd specify this in the `version` field of the module field of the `service.yaml`. For the example above:

```yaml
modules:
- name: github.com/stencil/example-module
	version: v1.0.0
```
